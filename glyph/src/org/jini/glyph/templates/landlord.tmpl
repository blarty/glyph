package $[packageName];

import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.server.ExportException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import net.jini.core.event.RemoteEventListener;
import net.jini.core.lease.Lease;
import net.jini.core.lease.LeaseDeniedException;
import net.jini.core.lease.LeaseMapException;
import net.jini.core.lease.UnknownLeaseException;
import net.jini.export.Exporter;
import net.jini.id.ReferentUuid;
import net.jini.id.Uuid;
import net.jini.id.UuidFactory;
import net.jini.jeri.BasicILFactory;
import net.jini.jeri.BasicJeriExporter;
import net.jini.jeri.tcp.TcpServerEndpoint;

import com.sun.jini.constants.TimeConstants;
import com.sun.jini.landlord.FixedLeasePeriodPolicy;
import com.sun.jini.landlord.Landlord;
import com.sun.jini.landlord.LeaseFactory;
import com.sun.jini.landlord.LeasePeriodPolicy;
import com.sun.jini.landlord.LeasedResource;
import org.jini.glyph.LandlordHelper;


import net.jini.config.Configuration;
import net.jini.config.ConfigurationProvider;
import net.jini.config.ConfigurationException;


public class $[className]Landlord implements Landlord, ReferentUuid, Remote {

	private LandlordHelper helper;

	protected Map leases = new HashMap();
	private Logger log = Logger.getLogger("$[packageName]");
	Uuid myId = null;
	protected LeaseFactory myFactory;
	protected LeasePeriodPolicy myGrantPolicy;
	private Reaper reaper = new Reaper();
	private Configuration config;
	private long reaperSeconds;
	/**
	 * Create the landlord and export the factory
	 */
	public $[className]Landlord(LandlordHelper helper, Configuration config) {
		super();
		this.helper = helper;
		this.config = config;
		// URGENT Complete constructor stub for ChangeLandlord
		myId = UuidFactory.generate();
		try {
			Exporter exp = (Exporter) config.getEntry("$[packageName].$[className]Landlord", "landlordExporter", Exporter.class,new BasicJeriExporter(TcpServerEndpoint.getInstance(0), new BasicILFactory()));
			myGrantPolicy = (LeasePeriodPolicy)config.getEntry("$[packageName].$[className]Landlord", "grantPolicy", LeasePeriodPolicy.class, new FixedLeasePeriodPolicy(1 * TimeConstants.MINUTES, 30 * TimeConstants.SECONDS));
			reaperSeconds = (Integer) config.getEntry("$[packageName].$[className]Landlord", "reaperSeconds", Integer.class,new Integer(30)) *1000L;
			myFactory = new LeaseFactory((Landlord) exp.export(this), myId);
		} catch (ExportException e) {
			e.printStackTrace();
		} catch(ConfigurationException e){
			e.printStackTrace();
		}
		reaper.start();
        log.info("$[className]Landlord system Initialised");
        System.out.println("$[className]Landlord system Initialised");
	}

	/**
	 * Kill an existing lease
	 * 
	 * @param obj
	 * @throws net.jini.core.lease.UnknownLeaseException
	 */
	public void killLease(Uuid obj) throws net.jini.core.lease.UnknownLeaseException {
		log.info("Killing Lease ID: " + obj.toString());
		if (leases.containsKey(obj))
			leases.remove(obj);
		else
			throw new UnknownLeaseException("Unknown lease");
	}

	/**
	 * Create a new lease with a given duration for the connection
	 * 
	 * @param conn
	 * @param reqduration
	 * @return @throws
	 *              LeaseDeniedException
	 */
	public Lease newLease($[className] object, long reqduration) throws LeaseDeniedException {
		log.info("New Lease Requested for " + object.getClass().getName());

		Uuid regCookie = UuidFactory.generate();
		$[className]LeasedResource res = new $[className]LeasedResource(object, regCookie);
		LeasePeriodPolicy.Result r = myGrantPolicy.grant(res, reqduration);
		res.setExpiration(r.expiration);
		leases.put(regCookie, res);
		
		log.info("Cookie:" + regCookie);
		
		log.info("Creating new Lease from Policy now");
		return myFactory.newLease(regCookie, res.getExpiration());
	}

	/**
	 * Allow a client Renew an existing lease
	 */
	public long renew(Uuid cookie, long duration) throws LeaseDeniedException, UnknownLeaseException, RemoteException {
		if (!leases.containsKey(cookie))
			throw new UnknownLeaseException();
		LeasedResource res = (LeasedResource) leases.get(cookie);
		LeasePeriodPolicy policy = myGrantPolicy;
		log.info("Renewing a lease");
		synchronized (res) {
			if (res.getExpiration() <= System.currentTimeMillis()) {
				// Lease has expired, don't renew
				throw new UnknownLeaseException("Lease expired");
			}
			// No one can expire the lease, so it is safe to update.
			final LeasePeriodPolicy.Result r = policy.renew(res, duration);
			res.setExpiration(r.expiration);
			return r.duration;
		}
	}

	/**
	 * Cancel an existing lease
	 */
	public void cancel(Uuid cookie) throws UnknownLeaseException, RemoteException {
		// TODO Complete method stub for cancel
		killLease(cookie);
	}

	/**
	 * Renew a set of leases
	 */
	public RenewResults renewAll(Uuid[] cookies, long[] durations) throws RemoteException {
		boolean somethingDenied = false;
		long[] granted = new long[cookies.length];
		Exception[] denied = new Exception[cookies.length + 1];
		for (int i = 0; i < cookies.length; i++) {
			try {
				granted[i] = renew(cookies[i], durations[i]);
				denied[i] = null;
			} catch (Exception ex) {
				somethingDenied = true;
				granted[i] = -1;
				denied[i] = ex;
			}
		}
		if (!somethingDenied)
			denied = null;
		return new Landlord.RenewResults(granted, denied);
	}

	/**
	 * Cancel a set of leases
	 */
	public Map cancelAll(Uuid[] cookies) throws RemoteException {
		Map exMap = null;
		LeaseMapException lmEx = null;
		for (int i = 0; i < cookies.length; i++) {
			try {
				cancel(cookies[i]);
			} catch (Exception e) {
				if (lmEx == null) {
					exMap = new HashMap();
					lmEx = new LeaseMapException(null, exMap);
				}
				exMap.put(myFactory.newLease(cookies[i], 0), e);
			}
		}
		if (lmEx != null)
			return exMap;
		else
			return null;
	}



   public class Reaper extends Thread {
		/**
		 * Run the xpiration checking, removing any expired leases
		 */
		public void run() {
			for (;;) {
				synchronized (leases) {
					try {
						List keystoremove = Collections.synchronizedList(new ArrayList());
						Iterator iter = leases.entrySet().iterator();

						while (iter.hasNext()) {
							Map.Entry leaseEntry = (Map.Entry) iter.next();
							Object obj = leaseEntry.getValue();
							LeasedResource lconn = (LeasedResource) obj;
							if ((lconn.getExpiration() + (15 * TimeConstants.SECONDS)) < System.currentTimeMillis()) {
								Uuid leaseKey = (Uuid) leaseEntry.getKey();

								log.info("...expiring a lease with key " + leaseKey);
								keystoremove.add(leaseKey);
							}
						}
						for (Iterator removeIter = keystoremove.iterator(); removeIter.hasNext();) {

							log.finer("Deallocating");
							Uuid ref = (Uuid) removeIter.next();
							$[className]LeasedResource res = ($[className]LeasedResource) leases.remove(ref);
							if (!helper.deallocateLease(res)) {
								log.info("Returning to lease set");
								leases.put(ref, res);
							}
						}
						keystoremove.clear();
					} catch (Exception ex) {
						System.out.println(new java.util.Date() + ": Err: " + ex.getMessage());
						ex.printStackTrace();
					}
				}
				try {
					Thread.sleep(10 * 1000L);
					
				} catch (Exception ex) {
					System.out.println(new java.util.Date() + ": Err: " + ex.getMessage());
					ex.printStackTrace();
				}
			}
		}
	}
	
	public Uuid getReferentUuid() {
		return myId;
	}
	
}
